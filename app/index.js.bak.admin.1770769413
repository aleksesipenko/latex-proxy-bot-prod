import { Telegraf, Markup } from "telegraf";
import Database from "better-sqlite3";
import crypto from "crypto";

const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = Number(process.env.ADMIN_ID);

const PROXY_SERVER = process.env.PROXY_SERVER || "45.140.146.233";
const PROXY_PORT = process.env.PROXY_PORT || "443";
const PROXY_SECRET = process.env.PROXY_SECRET || "";

if (!BOT_TOKEN) throw new Error("BOT_TOKEN missing");
if (!ADMIN_ID) throw new Error("ADMIN_ID missing");

const db = new Database("/data/bot.db");

db.exec(`
CREATE TABLE IF NOT EXISTS users (
  tg_id INTEGER PRIMARY KEY,
  username TEXT,
  first_name TEXT,
  last_name TEXT,
  status TEXT NOT NULL DEFAULT new,
  device_limit INTEGER DEFAULT 0,
  devices_used INTEGER NOT NULL DEFAULT 0,
  expires_at INTEGER DEFAULT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  menu_msg_id INTEGER DEFAULT NULL
);

CREATE TABLE IF NOT EXISTS requests (
  id TEXT PRIMARY KEY,
  tg_id INTEGER NOT NULL,
  status TEXT NOT NULL,
  created_at INTEGER NOT NULL
);
`);


// lightweight migration (ignore if column already exists)
try {
  db.prepare("ALTER TABLE users ADD COLUMN menu_msg_id INTEGER").run();
} catch {}

const now = () => Math.floor(Date.now() / 1000);


const PS = {
  start: [
    "P.S. Ð•ÑÐ»Ð¸ ÑÐ²ÑÐ·ÑŒ Ð²Ð´Ñ€ÑƒÐ³ Â«ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ð¾Â» ÑÑ‚Ð°Ð»Ð° ÐºÐ°Ð¿Ñ€Ð¸Ð·Ð½Ð¾Ð¹ â€” Ñƒ Ð½Ð°Ñ ÐµÑÑ‚ÑŒ ÑÐ²Ð¾Ð¸ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¸Ðµ Ð»Ð°Ð¹Ñ„Ñ…Ð°ÐºÐ¸ ðŸ˜‰",
    "P.S. Ð¢ÑƒÑ‚ Ð²ÑÑ‘ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾. Ð”Ð°Ð¶Ðµ ÐµÑÐ»Ð¸ Ð¼Ð¸Ñ€Ñƒ Ð²Ð¾ÐºÑ€ÑƒÐ³ Ð½Ñ€Ð°Ð²Ð¸Ñ‚ÑÑ ÑƒÑÐ»Ð¾Ð¶Ð½ÑÑ‚ÑŒ.",
    "P.S. Ð¯ Ð½Ðµ ÑÐ¿Ð¾Ñ€ÑŽ Ñ Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒÑŽ. Ð¯ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð´ÐµÐ»Ð°ÑŽ Ñ‚Ð°Ðº, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ð½Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð°.",
    "P.S. ÐÐ¸Ñ‡ÐµÐ³Ð¾ Ð½ÐµÐ·Ð°ÐºÐ¾Ð½Ð½Ð¾Ð³Ð¾. ÐŸÑ€Ð¾ÑÑ‚Ð¾ ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ.",
    "P.S. Ð•ÑÐ»Ð¸ Ñ‚Ñ‹ ÑÑ‚Ð¾ Ñ‡Ð¸Ñ‚Ð°ÐµÑˆÑŒ â€” Ð·Ð½Ð°Ñ‡Ð¸Ñ‚, Ñ‚Ñ‹ Ð¸Ð· Ñ‚ÐµÑ…, ÐºÑ‚Ð¾ Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‡Ð¸Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ. Ð£Ð²Ð°Ð¶Ð°ÑŽ."
  ],
  requestSent: [
    "P.S. Ð¯ ÑƒÐ¶Ðµ ÑƒÐ²Ð¸Ð´ÐµÐ»Ð° Ð·Ð°ÑÐ²ÐºÑƒ. Ð”Ð°, Ñ Ð±Ñ‹ÑÑ‚Ñ€Ð°Ñ. ÐÐµ Ð·Ð°Ð´Ð°Ð²Ð°Ð¹ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ¾Ð² ðŸ™‚",
    "P.S. ÐÐµ Ð¿ÐµÑ€ÐµÐ¶Ð¸Ð²Ð°Ð¹, Ñ Ð½Ðµ Ð¿Ð¾Ñ‚ÐµÑ€ÑÑŽ Ñ‚ÐµÐ±Ñ Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸. Ð¯ Ð¶Ðµ Ð½Ðµ Ð³Ð¾ÑÑƒÑÐ»ÑƒÐ³Ð¸.",
    "P.S. ÐŸÐ¾ÐºÐ° Ð¶Ð´Ñ‘ÑˆÑŒ â€” Ð³Ð´Ðµâ€‘Ñ‚Ð¾ Ð¾Ð´Ð¸Ð½ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€ Ð³Ñ€ÑƒÑÑ‚Ð¸Ñ‚. Ð¡Ð¾Ð²ÑÐµÐ¼ Ñ‡ÑƒÑ‚ÑŒâ€‘Ñ‡ÑƒÑ‚ÑŒ.",
    "P.S. ÐÐ°Ð¶Ð°Ð» ÐºÐ½Ð¾Ð¿ÐºÑƒ â€” Ð·Ð½Ð°Ñ‡Ð¸Ñ‚, Ñ‚Ñ‹ Ð² Ñ‚ÐµÐ¼Ðµ.",
    "P.S. Ð•ÑÐ»Ð¸ Ñ‡Ñ‚Ð¾, Ñ Ñ‚ÑƒÑ‚. Ð¯ Ð½Ðµ Ð¸ÑÑ‡ÐµÐ·Ð°ÑŽ."
  ],
  accessGranted: [
    "P.S. ÐÐ°Ð¶Ð¼Ð¸ ÐºÐ½Ð¾Ð¿ÐºÑƒ â€” Ð¸ Ð´Ð°Ð»ÑŒÑˆÐµ Ð²ÑÑ‘ ÑÐ´ÐµÐ»Ð°ÐµÑ‚ Telegram. ÐšÑ€Ð°ÑÐ¸Ð²Ð¾. ÐŸÐ¾Ñ‡Ñ‚Ð¸ ÐºÐ°Ðº Ð±ÑƒÐ´Ñ‚Ð¾ Ñ‚Ð°Ðº Ð¸ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ.",
    "P.S. Ð•ÑÐ»Ð¸ Ñ‡Ñ‚Ð¾-Ñ‚Ð¾ Ð½Ðµ Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ â€” ÑÑ‚Ð¾ Ð½Ðµ Ñ‚Ñ‹. Ð­Ñ‚Ð¾â€¦ Â«Ð°Ñ‚Ð¼Ð¾ÑÑ„ÐµÑ€Ð°Â» ðŸ˜Œ",
    "P.S. Ð¯ Ð±Ñ‹ ÑÐºÐ°Ð·Ð°Ð»Ð° Â«Ð´Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒÂ», Ð½Ð¾ Ð¼Ñ‹ Ñ‚ÑƒÑ‚ Ð½Ðµ ÐºÐ»ÑƒÐ±. ÐœÑ‹ Ñ‚ÑƒÑ‚ Ð·Ð° ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ.",
    "P.S. Ð˜Ð½Ð¾Ð³Ð´Ð° ÑÐ²Ð¾Ð±Ð¾Ð´Ð° Ð²Ñ‹Ð³Ð»ÑÐ´Ð¸Ñ‚ ÐºÐ°Ðº Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð°Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹.",
    "P.S. Ð¢Ñ‹ ÑÑ‚Ð¾ Ð½Ðµ Ð²Ð¸Ð´ÐµÐ». Ð¯ ÑÑ‚Ð¾ Ð½Ðµ Ð¿Ð¸ÑÐ°Ð»Ð° ðŸ˜‰"
  ],
  howto: [
    "P.S. Ð”Ð°, ÑÑ‚Ð¾ Ð²Ñ‹Ð³Ð»ÑÐ´Ð¸Ñ‚ ÐºÐ°Ðº Â«Ñ‚Ñ€Ð¸ ÑˆÐ°Ð³Ð°Â». ÐÐ° ÑÐ°Ð¼Ð¾Ð¼ Ð´ÐµÐ»Ðµ ÑÑ‚Ð¾ Ñ€Ð¸Ñ‚ÑƒÐ°Ð» Ð¸Ð·Ð³Ð½Ð°Ð½Ð¸Ñ Ð»Ð°Ð³Ð¾Ð².",
    "P.S. Ð•ÑÐ»Ð¸ Ñ‚Ñ‹ Ñ‡Ð¸Ñ‚Ð°ÐµÑˆÑŒ ÑÑ‚Ð¾ â€” Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ ÐºÐ½Ð¾Ð¿ÐºÐ° Ð½Ðµ Ð¾Ñ‚ÐºÑ€Ñ‹Ð»Ð°ÑÑŒ. ÐœÑ‹ Ñ Ñ‚Ð¾Ð±Ð¾Ð¹ Ð² Ð¾Ð´Ð½Ð¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ.",
    "P.S. Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾, Ñ‡Ñ‚Ð¾ ÑÐ»ÐµÐ´ÑƒÐµÑˆÑŒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ð¸. Ð¯ ÑÑ‚Ð°Ñ€Ð°Ð»Ð°ÑÑŒ Ð¿Ð¸ÑÐ°Ñ‚ÑŒ ÐµÑ‘ Ñ‚Ð°Ðº, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ðµ Ð±ÐµÑÐ¸Ñ‚ÑŒ.",
    "P.S. Ð”Ð°, Ñ Ñ‚Ð¾Ð¶Ðµ Ð»ÑŽÐ±Ð»ÑŽ, ÐºÐ¾Ð³Ð´Ð° Ð²ÑÑ‘ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ñ€Ð°Ð·Ð°. ÐÐ¾ Ð¼Ð¸Ñ€ Ð½Ðµ Ð²ÑÐµÐ³Ð´Ð° ÑÐ¾Ð³Ð»Ð°ÑÐµÐ½.",
    "P.S. Ð•ÑÐ»Ð¸ ÑÐ¾Ð²ÑÐµÐ¼ Ð±ÐµÐ´Ð° â€” Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð½Ð°Ð¿Ð¸ÑˆÐ¸ Â«ÐÐµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚Â», Ñ Ð¿Ð¾Ð¹Ð¼Ñƒ."
  ]
};

function pickPs(stage, seed) {
  const arr = PS[stage] || [];
  if (!arr.length) return "";
  const idx = Math.abs((seed * 9301 + 49297) % 233280) % arr.length;
  return arr[idx];
}

async function renderMenu(ctx, { text, keyboard }) {
  const userId = ctx.from.id;
  const u = getUser(userId);
  const chatId = (ctx.chat && ctx.chat.id) ? ctx.chat.id : userId;

  if (u && u.menu_msg_id) {
    try {
      await ctx.telegram.editMessageText(chatId, u.menu_msg_id, undefined, text, {
        reply_markup: keyboard.reply_markup,
      });
      return u.menu_msg_id;
    } catch (e) {
      try { await ctx.telegram.deleteMessage(chatId, u.menu_msg_id); } catch {}
    }
  }

  const sent = await ctx.telegram.sendMessage(chatId, text, keyboard);
  db.prepare("UPDATE users SET menu_msg_id=?, updated_at=? WHERE tg_id=?").run(sent.message_id, now(), userId);
  return sent.message_id;
}


async function renderMenuForUser(userId, { text, keyboard }) {
  const u = getUser(userId);
  const chatId = userId;

  if (u && u.menu_msg_id) {
    try {
      await bot.telegram.editMessageText(chatId, u.menu_msg_id, undefined, text, {
        reply_markup: keyboard.reply_markup,
      });
      return u.menu_msg_id;
    } catch (e) {
      try { await bot.telegram.deleteMessage(chatId, u.menu_msg_id); } catch {}
    }
  }

  const sent = await bot.telegram.sendMessage(chatId, text, keyboard);
  db.prepare("UPDATE users SET menu_msg_id=?, updated_at=? WHERE tg_id=?").run(sent.message_id, now(), userId);
  return sent.message_id;
}


function upsertUser(from) {
  const t = now();
  db.prepare(`
    INSERT INTO users(tg_id, username, first_name, last_name, status, created_at, updated_at)
    VALUES(?,?,?,?, 'new', ?,?)
    ON CONFLICT(tg_id) DO UPDATE SET
      username=excluded.username,
      first_name=excluded.first_name,
      last_name=excluded.last_name,
      updated_at=excluded.updated_at
  `).run(from.id, from.username || null, from.first_name || null, from.last_name || null, t, t);
}

function getUser(tgId) {
  return db.prepare("SELECT * FROM users WHERE tg_id=?").get(tgId);
}

function setUserStatus(tgId, status) {
  db.prepare("UPDATE users SET status=?, updated_at=? WHERE tg_id=?").run(status, now(), tgId);
}

function setUserAccess(tgId, { deviceLimit, expiresAt }) {
  db.prepare("UPDATE users SET status=approved, device_limit=?, expires_at=?, updated_at=? WHERE tg_id=?")
    .run(deviceLimit, expiresAt ?? null, now(), tgId);
}

function revokeUser(tgId) {
  db.prepare("UPDATE users SET status=revoked, updated_at=? WHERE tg_id=?").run(now(), tgId);
}

function banUser(tgId) {
  db.prepare("UPDATE users SET status=banned, updated_at=? WHERE tg_id=?").run(now(), tgId);
}

function fmtUser(u) {
  const uname = u.username ? `@${u.username}` : "(no username)";
  const name = `${u.first_name || ""} ${u.last_name || ""}`.trim();
  return `${name} ${uname} | id:${u.tg_id}`;
}

function isApproved(u) {
  if (!u) return false;
  if (u.status !== "approved") return false;
  if (u.expires_at && now() > u.expires_at) return false;
  return true;
}

function proxyUrl() {
  const secret = PROXY_SECRET;
  if (!secret) return null;
  return `https://t.me/proxy?server=${PROXY_SERVER}&port=${PROXY_PORT}&secret=${secret}`;
}

function requireAdmin(ctx) {
  if (ctx.from?.id !== ADMIN_ID) {
    ctx.reply("ÐÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð°");
    return false;
  }
  return true;
}

function userMenu(opts = {}) {
  const { approved = false } = opts;
  const rows = [];
  if (!approved) {
    rows.push([Markup.button.callback("Ð—Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿", "req_access")]);
  } else {
    rows.push([Markup.button.callback("ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐºÑÐ¸", "get_proxy")]);
    rows.push([Markup.button.callback("Ð˜Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ", "howto")]);
  }
  return Markup.inlineKeyboard(rows);
}

function adminReqCard(reqId) {
  return Markup.inlineKeyboard([
    [Markup.button.callback("âœ… ÐŸÑ€Ð¸Ð½ÑÑ‚ÑŒ", `approve:${reqId}`), Markup.button.callback("âŒ ÐžÑ‚ÐºÐ°Ð·Ð°Ñ‚ÑŒ", `deny:${reqId}`)],
    [Markup.button.callback("ðŸ§± Ð‘Ð°Ð½", `banreq:${reqId}`)]
  ]);
}

function adminAccessPicker(reqId) {
  return Markup.inlineKeyboard([
    [Markup.button.callback("1 ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾", `setdev:${reqId}:1`), Markup.button.callback("2", `setdev:${reqId}:2`), Markup.button.callback("3", `setdev:${reqId}:3`), Markup.button.callback("5", `setdev:${reqId}:5`)],
    [Markup.button.callback("7 Ð´Ð½ÐµÐ¹", `setexp:${reqId}:7`), Markup.button.callback("30 Ð´Ð½ÐµÐ¹", `setexp:${reqId}:30`), Markup.button.callback("Ð‘ÐµÐ· ÑÑ€Ð¾ÐºÐ°", `setexp:${reqId}:0`)]
  ]);
}

const bot = new Telegraf(BOT_TOKEN);

bot.start(async (ctx) => {
  upsertUser(ctx.from);
  const u = getUser(ctx.from.id);
  if (u?.status === "banned") return ctx.reply("Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð·Ð°ÐºÑ€Ñ‹Ñ‚");

  const approved = isApproved(u);

  await renderMenu(ctx, {
    text: `ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð¯ Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÑŽ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒÑÑ Ðº Ð¿Ñ€Ð¾ÐºÑÐ¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ²ÑÐ·ÑŒ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð° ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾.

ÐšÐ°Ðº ÑÑ‚Ð¾ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚:
1) ÐÐ°Ð¶Ð¼Ð¸ Â«Ð—Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿Â»
2) Ð¯ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ñƒ

âš ï¸ Ð’Ð°Ð¶Ð½Ð¾: Ð¡ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½Ð½Ñ‹Ð¼ VPN MTProtoâ€‘Ð¿Ñ€Ð¾ÐºÑÐ¸ Ñ‡Ð°ÑÑ‚Ð¾ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚.

${pickPs("start", ctx.from.id)}`,
    keyboard: userMenu({ approved })
  });
});

bot.action("req_access", async (ctx) => {
  upsertUser(ctx.from);
  const u = getUser(ctx.from.id);
  if (u.status === "banned") return ctx.answerCbQuery("Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð·Ð°ÐºÑ€Ñ‹Ñ‚", { show_alert: true });
  if (u.status === "approved" && isApproved(u)) return ctx.answerCbQuery("Ð£ Ñ‚ÐµÐ±Ñ ÑƒÐ¶Ðµ ÐµÑÑ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿");

  const reqId = crypto.randomUUID();
  db.prepare("INSERT INTO requests(id,tg_id,status,created_at) VALUES(?,?, 'pending', ?)").run(reqId, ctx.from.id, now());
  setUserStatus(ctx.from.id, "pending");

  await ctx.answerCbQuery("ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾");
  await renderMenu(ctx, {
  text: `Ð—Ð°ÑÐ²ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð° âœ…

${pickPs("requestSent", ctx.from.id)}`,
  keyboard: userMenu({ approved: false })
});

  const nu = getUser(ctx.from.id);
  await bot.telegram.sendMessage(
    ADMIN_ID,
    `ÐÐ¾Ð²Ð°Ñ Ð·Ð°ÑÐ²ÐºÐ° Ð½Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿\n${fmtUser(nu)}`,
    adminReqCard(reqId)
  );
});

bot.action("get_proxy", async (ctx) => {
  upsertUser(ctx.from);
  const u = getUser(ctx.from.id);
  if (!isApproved(u)) return ctx.answerCbQuery("ÐÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° (Ð¸Ð»Ð¸ Ð¸ÑÑ‚Ñ‘Ðº)", { show_alert: true });

  const url = proxyUrl();
  if (!url) return ctx.answerCbQuery("ÐŸÑ€Ð¾ÐºÑÐ¸ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ (ÑÐµÐºÑ€ÐµÑ‚ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½)", { show_alert: true });

  if (u.device_limit > 0 && u.devices_used >= u.device_limit) {
    return ctx.answerCbQuery("Ð›Ð¸Ð¼Ð¸Ñ‚ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ð¸ÑÑ‡ÐµÑ€Ð¿Ð°Ð½. ÐŸÐ¾Ð¿Ñ€Ð¾ÑÐ¸ Ð°Ð¿Ð´ÐµÐ¹Ñ‚", { show_alert: true });
  }
  if (u.devices_used == 0) {
    db.prepare("UPDATE users SET devices_used = devices_used + 1, updated_at=? WHERE tg_id=?").run(now(), u.tg_id);
  }

  await ctx.answerCbQuery("ÐžÐº");

  await renderMenu(ctx, {
    text: `Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½ âœ…

ÐÐ°Ð¶Ð¼Ð¸ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ â€” Telegram Ð¾Ñ‚ÐºÑ€Ð¾ÐµÑ‚ Ð¾ÐºÐ½Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾ÐºÑÐ¸.

âš ï¸ Ð•ÑÐ»Ð¸ Ñƒ Ñ‚ÐµÐ±Ñ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½ VPN Ð¸ Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ â€” Ð²Ñ‹ÐºÐ»ÑŽÑ‡Ð¸ VPN Ð¸ Ð²ÐºÐ»ÑŽÑ‡Ð¸ Ð¿Ñ€Ð¾ÐºÑÐ¸ Ð·Ð°Ð½Ð¾Ð²Ð¾.

${pickPs("accessGranted", ctx.from.id)}` ,
    keyboard: Markup.inlineKeyboard([[Markup.button.url("ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐºÑÐ¸", url)]])
  });
});

bot.action("howto", async (ctx) => {
  await ctx.answerCbQuery();
  await renderMenu(ctx, {
    text: `ÐšÐ°Ðº Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐºÑÐ¸ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ:

1) Telegram â†’ ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ â†’ Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¸ Ð¿Ð°Ð¼ÑÑ‚ÑŒ â†’ ÐŸÑ€Ð¾ÐºÑÐ¸
2) Â«Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐºÑÐ¸Â» â†’ MTProto
3) Ð’ÑÑ‚Ð°Ð²ÑŒ Server / Port / Secret

${pickPs("howto", ctx.from.id)}`,
    keyboard: userMenu({ approved: isApproved(getUser(ctx.from.id)) })
  });
});

bot.action(/approve:(.+)/, async (ctx) => {
  if (!requireAdmin(ctx)) return;
  const reqId = ctx.match[1];
  const req = db.prepare("SELECT * FROM requests WHERE id=?").get(reqId);
  if (!req || req.status !== "pending") return ctx.answerCbQuery("Ð£Ð¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾");

  db.prepare("UPDATE requests SET status=approved WHERE id=?").run(reqId);
  setUserStatus(req.tg_id, "approved");

  await ctx.answerCbQuery("ÐžÐº");
  await ctx.editMessageText("ÐŸÑ€Ð¸Ð½ÑÑ‚Ð¾. Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð»Ð¸Ð¼Ð¸Ñ‚ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ð¸ ÑÑ€Ð¾Ðº", adminAccessPicker(reqId));
});

bot.action(/deny:(.+)/, async (ctx) => {
  if (!requireAdmin(ctx)) return;
  const reqId = ctx.match[1];
  const req = db.prepare("SELECT * FROM requests WHERE id=?").get(reqId);
  if (!req || req.status !== "pending") return ctx.answerCbQuery("Ð£Ð¶Ðµ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾");

  db.prepare("UPDATE requests SET status=denied WHERE id=?").run(reqId);
  setUserStatus(req.tg_id, "denied");

  await ctx.answerCbQuery("ÐžÐº");
  await ctx.editMessageText("ÐžÑ‚ÐºÐ»Ð¾Ð½ÐµÐ½Ð¾");
  try { await bot.telegram.sendMessage(req.tg_id, "Ð¡Ð¾Ñ€Ñ€Ð¸, Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ð½Ðµ Ð²Ñ‹Ð´Ð°Ð½"); } catch {}
});

bot.action(/banreq:(.+)/, async (ctx) => {
  if (!requireAdmin(ctx)) return;
  const reqId = ctx.match[1];
  const req = db.prepare("SELECT * FROM requests WHERE id=?").get(reqId);
  if (!req) return ctx.answerCbQuery("ÐÐµ Ð½Ð°ÑˆÐ»Ð° Ð·Ð°ÑÐ²ÐºÑƒ");

  banUser(req.tg_id);
  db.prepare("UPDATE requests SET status=banned WHERE id=?").run(reqId);

  await ctx.answerCbQuery("ÐžÐº");
  await ctx.editMessageText("ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð·Ð°Ð±Ð°Ð½ÐµÐ½");
  try { await bot.telegram.sendMessage(req.tg_id, "Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð·Ð°ÐºÑ€Ñ‹Ñ‚"); } catch {}
});

const pendingAccess = new Map(); // reqId -> { deviceLimit, expiresDays }

bot.action(/setdev:(.+):(\d+)/, async (ctx) => {
  if (!requireAdmin(ctx)) return;
  const reqId = ctx.match[1];
  const n = Number(ctx.match[2]);
  const s = pendingAccess.get(reqId) || { deviceLimit: n, expiresDays: 30 };
  s.deviceLimit = n;
  pendingAccess.set(reqId, s);
  await ctx.answerCbQuery(`Ð›Ð¸Ð¼Ð¸Ñ‚: ${n}`);
});

bot.action(/setexp:(.+):(\d+)/, async (ctx) => {
  if (!requireAdmin(ctx)) return;
  const reqId = ctx.match[1];
  const d = Number(ctx.match[2]);
  const s = pendingAccess.get(reqId) || { deviceLimit: 2, expiresDays: d };
  s.expiresDays = d;
  pendingAccess.set(reqId, s);

  const req = db.prepare("SELECT * FROM requests WHERE id=?").get(reqId);
  if (!req) return ctx.answerCbQuery("ÐÐµ Ð½Ð°ÑˆÐ»Ð° Ð·Ð°ÑÐ²ÐºÑƒ");

  const expiresAt = d == 0 ? null : now() + d * 86400;
  const deviceLimit = s.deviceLimit ?? 2;

  setUserAccess(req.tg_id, { deviceLimit, expiresAt });

  await ctx.answerCbQuery("Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð²Ñ‹Ð´Ð°Ð½");
  await ctx.editMessageText(`Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð²Ñ‹Ð´Ð°Ð½: ${deviceLimit} ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð², ÑÑ€Ð¾Ðº: ${d == 0 ? "Ð‘ÐµÐ· ÑÑ€Ð¾ÐºÐ°" : str(d) + " Ð´Ð½ÐµÐ¹"}`);

  try {
    // Push notification about approval (required)
    await bot.telegram.sendMessage(
      req.tg_id,
      `Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð²Ñ‹Ð´Ð°Ð½ âœ…
Ð›Ð¸Ð¼Ð¸Ñ‚ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²: ${deviceLimit}
Ð¡Ñ€Ð¾Ðº: ${d == 0 ? "Ð‘ÐµÐ· ÑÑ€Ð¾ÐºÐ°" : d + " Ð´Ð½ÐµÐ¹"}

${pickPs("accessGranted", req.tg_id)}`
    );

    // Auto-update the menu message to show new buttons
    const approved = true;
    await renderMenuForUser(req.tg_id, {
      text: `ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð¯ Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÑŽ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒÑÑ Ðº Ð¿Ñ€Ð¾ÐºÑÐ¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ²ÑÐ·ÑŒ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð° ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾.

âš ï¸ Ð’Ð°Ð¶Ð½Ð¾: Ð¡ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½Ð½Ñ‹Ð¼ VPN MTProtoâ€‘Ð¿Ñ€Ð¾ÐºÑÐ¸ Ñ‡Ð°ÑÑ‚Ð¾ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚.

${pickPs("start", req.tg_id)}`,
      keyboard: userMenu({ approved })
    });
  } catch {}
});

bot.launch();
process.on("SIGINT", () => bot.stop("SIGINT"));
process.on("SIGTERM", () => bot.stop("SIGTERM"));
